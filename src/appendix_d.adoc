:imagesdir: ./images

[[appendix_d]]
== Appendix D: M-mode TSM based deployment model

This deployment model targets systems whose design is constrained by real-time
requirements, formal verification objectives, or must operate on hardware with
limited capabilities due to power or silicon constrains.
It augments a feature-rich architecture with flexible ABI and dynamic resource
management. We defined a simplified implementation that facilitates safety and
security verification.
Typical examples of these systems include high-end embedded or edge systems
operating on less complex hardware than cloud-grade servers, and high-assurance
platforms where reduced architectural complexity simplifies formal verification
of properties such as correctness and isolation.

[id=dep3]
[caption="Figure {counter:image}"]
[title= ": M-mode TSM based deployment model for CoVE."]
image::img_11.png[align=center]

=== Overview
<<dep3>> shows that the deployment model supports a single confidential
supervisor domain in which the TSM runs along with the TSM driver in the M-mode.
This single confidential supervisor domain can host multiple TVMs. The TSM
enforces isolation of TVMs using G-stage page tables. It also isolates the
hosting supervisor domain (i.e., OS/VMM and any non-confidential applications
and VMs) from the confidential supervisor domain (TVMs) through a hardware memory
isolation mechanism, such as PMP. In this model, the supervisor domain access
protection (Smmtt) extension is not required, though its use is not precluded.
Accesses from I/O to confidential memory must be prevented, for example, though
the use of IOPMP.

[NOTE]
====
Since the TSM is not required to run in the HS-mode, this deployment model
supports systems that emulate the hypervisor extension or run TVMs and OS/VMM in
S-mode. The latter requires use of a hardware memory isolation mechanism that
enforces memory accesses to confidential memory while being only controlled by
the TSM, e.g., PMP.
====

=== Static Memory Partitioning
The deployment model should employ a static partitioning of memory into confidential
and non-confidential regions to simplify formal reasoning about the correctness
and isolation of TVM execution. The TSM should perform this partitioning early during
platform boot to gain the following advantages:

. simplified formal reasoning about memory ownership,
. attestation that covers static system configuration (e.g., values of PMP
registers),
. reduced attack surface between OS/VMM and the TSM, achieved through
preventing the OS/VMM from controlling the allocation of physical
pages to TVMs and by a narrower ABI.

[NOTE]
====
A potential drawback of static partitioning is underutilization of resources.
Specifically, the amount of confidential memory established during platform
may exceed the memory required by the TSM and TVMs at runtime.
In the absence of a mechanism to convert confidential memory pages to
non-confidential memory (as could be enabled by the Smmtt extension), the
hosting supervisor domain (i.e., the OS/VMM, applications, and VMs) cannot
reclaim or use memory over-provisioned to the confidential supervisor domain.
====

=== TVM creation
To reduce the complexity of the TSM implementation and its ABI, in this
deployment model the TSM should create a TVM as a result of a single operation
triggered with the sbi_covh_promote_to_tvm() call. Specifically, OS/VMM should
constructs a regular VM in non-confidential memory and requests the TSM to
promote it to a TVM. To do so, the TSM must copy the VM's data, page tables, and
the boot vCPU state into confidential memory. When the request succeeds, OS/VMM
marks the VM as a TVM, so that it can then properly resume its execution via the
TSM.

[NOTE]
====
The promotion mechanism enables use cases in which a running VM gets
promoted to a TVM. To support attestation, such promotion must occur when
the contents of VM's runtime state are predictable, allowing for reliable
computation of reference integrity measurements. However, certain use cases
may require promotion after that point and might even exclude some dirty VM pages
(like those containing custom boot firmware or provisioning code) from the TVM.
However, if your use case requires promotion after that point, then you must
exclude dirty VM pages by modifing the FDT to mark selected pages as
zero pages, and the TSM will clear these pages during promotion.
====

=== Further Recommendations
Embedded systems with real-time requirements must guarantee a fixed upper bound
on execution time. This necessitates determining the maximum number of
instructions that may execute between TVM context switches. For this reason,
this deployment model recommends use of an uninterruptible TSM. <<depd2>>
illustrates this operating mode, in which the TSM executes in M-mode and exposes
the COVH and COVG ABIs to the OS/VMM and TVM, respectively. During the TVM
execution, all exceptions and interrupts trap directly to the TSM, as determined
by the medeleg and mideleg configurations.

[id=depd2]
[caption="Figure {counter:image}"]
[title= ": Uninterruptible TSM operation in deployment model 3."]
image::img_12.png[align=center]